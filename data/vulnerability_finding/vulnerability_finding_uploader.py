import json
import random
from datetime import datetime, timedelta
from opensearchpy import OpenSearch, helpers
import urllib3
import logging
import argparse
from typing import Dict, Any
import uuid
import ipaddress

# Disable SSL warnings
urllib3.disable_warnings()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('vulnerability_finding.log')
    ]
)
logger = logging.getLogger(__name__)

class VulnerabilityFindingGenerator:
    def __init__(self):
        self.cve_years = range(2020, 2025)
        self.vulnerability_types = [
            "Buffer Overflow",
            "SQL Injection",
            "Cross-Site Scripting",
            "Remote Code Execution",
            "Privilege Escalation",
            "Authentication Bypass",
            "Information Disclosure",
            "Denial of Service"
        ]
        self.severities = [
            ("Critical", 5, range(9, 11)),
            ("High", 4, range(7, 9)),
            ("Medium", 3, range(4, 7)),
            ("Low", 2, range(1, 4)),
            ("Info", 1, range(0, 1))
        ]
        self.affected_systems = [
            {"type": "Operating System", "products": ["Linux", "Windows Server", "Ubuntu"]},
            {"type": "Web Server", "products": ["Apache", "Nginx", "IIS"]},
            {"type": "Database", "products": ["MySQL", "PostgreSQL", "MongoDB"]},
            {"type": "Application", "products": ["WordPress", "Drupal", "Joomla"]},
            {"type": "Network Device", "products": ["Cisco IOS", "Juniper", "F5"]}
        ]
        self.status_types = [
            ("Open", 1),
            ("In Progress", 2),
            ("Mitigated", 3),
            ("Remediated", 4),
            ("Risk Accepted", 5)
        ]

    def generate_cve(self) -> str:
        return f"CVE-{random.choice(self.cve_years)}-{random.randint(1000, 99999)}"

    def generate_random_event(self) -> Dict[str, Any]:
        timestamp = datetime.now() - timedelta(minutes=random.randint(0, 60))
        affected_system = random.choice(self.affected_systems)
        severity, severity_id, cvss_range = random.choice(self.severities)
        status, status_id = random.choice(self.status_types)
        cve_id = self.generate_cve()
        vuln_type = random.choice(self.vulnerability_types)
        
        event = {
            "class_uid": 2002,  # Vulnerability Finding
            "class_name": "Vulnerability Finding",
            "time": int(timestamp.timestamp() * 1000),
            "finding": {
                "uid": str(uuid.uuid4()),
                "title": f"{vuln_type} in {random.choice(affected_system['products'])}",
                "type": vuln_type,
                "message": f"Detected {vuln_type} vulnerability that could allow unauthorized access",
                "vulnerability": {
                    "id": cve_id,
                    "name": f"{vuln_type} Vulnerability",
                    "description": f"A {vuln_type.lower()} vulnerability in {random.choice(affected_system['products'])} allows attackers to...",
                    "cvss_score": round(random.uniform(cvss_range.start, cvss_range.stop), 1),
                    "references": [
                        f"https://nvd.nist.gov/vuln/detail/{cve_id}",
                        f"https://cve.mitre.org/cgi-bin/cvename.cgi?name={cve_id}"
                    ]
                },
                "resources": [{
                    "type": affected_system["type"],
                    "name": random.choice(affected_system["products"]),
                    "version": f"{random.randint(1,10)}.{random.randint(0,9)}.{random.randint(0,9)}",
                    "ip": str(ipaddress.IPv4Address(random.randint(0, 2**32 - 1))),
                    "hostname": f"host-{random.randint(1000, 9999)}"
                }],
                "remediation": {
                    "description": f"Update to the latest version and apply security patches",
                    "url": "https://security.example.com/patches",
                    "deadline": int((datetime.now() + timedelta(days=random.randint(1, 30))).timestamp() * 1000)
                }
            },
            "severity": severity,
            "severity_id": severity_id,
            "status": status,
            "status_id": status_id,
            "metadata": {
                "version": "1.1.0",
                "product": {
                    "name": "Vulnerability Scanner",
                    "vendor_name": "OCSF",
                    "version": "1.0.0"
                },
                "original_time": int(timestamp.timestamp() * 1000)
            }
        }

        # Add exploitation details for high severity findings
        if severity_id >= 4:
            event["finding"]["exploitation"] = {
                "status": random.choice(["Exploited", "PoC Available", "None Known"]),
                "availability": random.choice(["Public", "Limited", "Private"]),
                "complexity": random.choice(["Low", "Medium", "High"])
            }

        return event

def main():
    parser = argparse.ArgumentParser(description='Generate and upload vulnerability finding events to OpenSearch')
    parser.add_argument('--host', default='52.66.102.200', help='OpenSearch host')
    parser.add_argument('--port', type=int, default=9200, help='OpenSearch port')
    parser.add_argument('--user', default='admin', help='OpenSearch username')
    parser.add_argument('--password', default='Anubhav@321', help='OpenSearch password')
    parser.add_argument('--events', type=int, default=10, help='Number of events to generate')
    parser.add_argument('--batch-size', type=int, default=5, help='Upload batch size')

    args = parser.parse_args()
    logger.info("Starting vulnerability finding event generation and upload")

    # Initialize OpenSearch client
    client = OpenSearch(
        hosts=[{'host': args.host, 'port': args.port}],
        http_auth=(args.user, args.password),
        use_ssl=True,
        verify_certs=False,
        ssl_show_warn=False
    )

    # Create index template
    template_name = "ocsf-1.1.0-2002-vulnerability_finding"
    template = {
        "index_patterns": ["ocsf-1.1.0-2002-vulnerability_finding-*"],
        "template": {
            "settings": {
                "number_of_shards": 1,
                "number_of_replicas": 1
            },
            "mappings": {
                "properties": {
                    "finding": {
                        "properties": {
                            "uid": {"type": "keyword"},
                            "title": {"type": "text"},
                            "type": {"type": "keyword"},
                            "message": {"type": "text"},
                            "vulnerability": {
                                "properties": {
                                    "id": {"type": "keyword"},
                                    "name": {"type": "keyword"},
                                    "description": {"type": "text"},
                                    "cvss_score": {"type": "float"},
                                    "references": {"type": "keyword"}
                                }
                            },
                            "resources": {
                                "type": "nested",
                                "properties": {
                                    "type": {"type": "keyword"},
                                    "name": {"type": "keyword"},
                                    "version": {"type": "keyword"},
                                    "ip": {"type": "ip"},
                                    "hostname": {"type": "keyword"}
                                }
                            },
                            "exploitation": {
                                "properties": {
                                    "status": {"type": "keyword"},
                                    "availability": {"type": "keyword"},
                                    "complexity": {"type": "keyword"}
                                }
                            },
                            "remediation": {
                                "properties": {
                                    "description": {"type": "text"},
                                    "url": {"type": "keyword"},
                                    "deadline": {"type": "date"}
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    try:
        client.indices.put_template(name=template_name, body=template)
        logger.info(f"Successfully created index template: {template_name}")
    except Exception as e:
        logger.error(f"Failed to create index template: {e}")
        return

    # Generate and upload events
    generator = VulnerabilityFindingGenerator()
    events = [generator.generate_random_event() for _ in range(args.events)]

    # Upload in batches
    current_date = datetime.now().strftime("%Y.%m.%d")
    index_name = f"ocsf-1.1.0-2002-vulnerability_finding-{current_date}-000000"
    successful = 0
    failed = 0

    for i in range(0, len(events), args.batch_size):
        batch = events[i:i + args.batch_size]
        batch_num = (i // args.batch_size) + 1
        logger.info(f"Processing batch {batch_num}")
        
        actions = [
            {
                '_index': index_name,
                '_source': event
            }
            for event in batch
        ]

        try:
            success, failed_items = helpers.bulk(client, actions, stats_only=False, raise_on_error=False)
            successful += success
            if failed_items:
                failed += len(failed_items)
                logger.error(f"Failed items in batch {batch_num}: {failed_items}")
            logger.info(f"Batch {batch_num}: {success} successful, {len(failed_items) if failed_items else 0} failed")
        except Exception as e:
            logger.error(f"Bulk upload error in batch {batch_num}: {str(e)}")
            failed += len(batch)

    # Print summary
    logger.info("=" * 50)
    logger.info(f"Upload complete to index: {index_name}")
    logger.info(f"Total events processed: {args.events}")
    logger.info(f"Successfully uploaded: {successful}")
    logger.info(f"Failed uploads: {failed}")
    logger.info(f"Success rate: {(successful/args.events)*100:.2f}%")
    logger.info("=" * 50)

if __name__ == "__main__":
    main()
